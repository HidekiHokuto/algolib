# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Hideki Hokuto
# This file is distributed under the same license as the Algolib package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Algolib \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-30 00:41+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../source/api/algolib.numerics.rst:2
msgid "algolib.numerics package"
msgstr "algolib.numerics 包"

#: ../source/api/algolib.numerics.rst:5
msgid "Submodules"
msgstr "子模块"

#: ../source/api/algolib.numerics.rst:8
msgid "algolib.numerics.constants module"
msgstr "algolib.numerics.constants 模块"

#: algolib.numerics.constants:1 of
msgid "Centralized numerical constants for algolib."
msgstr "algolib 的集中化数值常数。"

#: algolib.numerics.constants:3 of
msgid "No imports from `math` or third-party libs: *pure Python floats only*."
msgstr "不依赖 math 或任何第三方库：仅使用*纯 Python 浮点数*。"

#: algolib.numerics.constants:4 of
msgid ""
"Values are given either as exact decimal, or with comments showing hex-float"
msgstr "常数值要么给出精确十进制，要么附带十六进制浮点表示"

#: algolib.numerics.constants:5 of
msgid "for traceability."
msgstr "以便追溯。"

#: algolib.numerics.constants:6 of
msgid ""
"Includes Cody-Waite style splits for stable range-reduction in exp/sin/cos."
msgstr "包含 Cody-Waite 风格的拆分，用于 exp/sin/cos 的稳定区间缩减。"

#: algolib.exceptions.NumericOverflowError:1 of
msgid "Bases: :py:class:`~algolib.exceptions.AlgolibError`, :py:class:`OverflowError`"
msgstr ""

#: algolib.exceptions.NumericOverflowError:1 of
msgid "Numeric overflow exposed as algolib-specific error."
msgstr ""

#: ../source/api/algolib.numerics.rst:16
msgid "algolib.numerics.diff module"
msgstr ""

#: algolib.numerics.diff.derivative_central:1 of
msgid ""
"Central difference derivative approximation with Richardson extrapolation."
msgstr ""
"Central difference derivative approximation with Richardson extrapolation."

#: algolib.numerics.diff.derivative_central:3 of
msgid ""
"Useful when f does not support complex input. Accuracy is O(h^2) per step "
"and improved by extrapolation."
msgstr "适用于 f 不支持复数输入的情况。每步精度为 O(h²)，可通过外推提高精度。"

#: algolib.numerics.diff.derivative_cstep:1 of
msgid "Complex-step derivative approximation:"
msgstr "复步长法导数近似："

#: algolib.numerics.diff.derivative_cstep:3 of
msgid "f'(x) ≈ Im(f(x + i*h)) / h"
msgstr ""

#: algolib.numerics.diff.derivative_cstep:5 of
msgid ""
"Requires f to support complex input. Very stable since there is no "
"subtractive cancellation."
msgstr "要求 f 支持复数输入。方法非常稳定，因为没有减法消去误差。"

#: ../source/api/algolib.numerics.rst:24
msgid "algolib.numerics.exp module"
msgstr ""

#: algolib.numerics.exp.exp:1 of
msgid ""
"Compute the natural exponential :math:`e^x` using Cody-Waite style range "
"reduction and a Padé [3/3] kernel, without relying on :mod:`math`."
msgstr ""
"使用 Cody-Waite 区间缩减和 Padé [3/3] 核来计算自然指数 e^x，不依"
"赖 :mod:`math` 模块。"

#: algolib.numerics.exp.exp:5 of
msgid "Algorithm"
msgstr ""

#: algolib.numerics.exp.exp:6 of
msgid "Range reduction:"
msgstr ""

#: algolib.numerics.exp.exp:7 of
#, python-brace-format
msgid "Choose integer :math:`k = \\text{round}(x / \\ln 2)`."
msgstr ""

#: algolib.numerics.exp.exp:8 of
msgid ""
"Let :math:`r = x - k \\ln 2` computed via ``LN2_HI`` + ``LN2_LO`` splitting "
"to reduce cancellation."
msgstr ""

#: algolib.numerics.exp.exp:9 of
#, python-brace-format
msgid "Then :math:`\\exp{x} = 2^k \\cdot \\exp{r}`."
msgstr ""

#: algolib.numerics.exp.exp:11 of
msgid "Kernel approximation on :math:`r` in :math:`[-\\ln2/2, \\ln2/2]`:"
msgstr ""

#: algolib.numerics.exp.exp:12 of
msgid "Use a [3/3] Padé approximant:"
msgstr ""

#: algolib.numerics.exp.exp:13 of
msgid "exp(r) ≈ (120 + 60r + 12r^2 + r^3) / (120 - 60r + 12r^2 - r^3)."
msgstr ""

#: algolib.numerics.exp.exp:15 of
msgid "Reconstruct with :math:`2^k`."
msgstr ""

#: algolib.numerics.exp.exp:19 of
msgid "Special cases"
msgstr ""

#: algolib.numerics.exp.exp:20 of
msgid "exp(+inf) = +inf"
msgstr ""

#: algolib.numerics.exp.exp:21 of
msgid "exp(-inf) = 0.0"
msgstr ""

#: algolib.numerics.exp.exp:22 of
msgid "exp(NaN)  = NaN"
msgstr ""

#: algolib.numerics.exp.exp of
msgid "param x"
msgstr ""

#: algolib.numerics.exp.exp:24 of
msgid "Input value."
msgstr ""

#: algolib.numerics.exp.exp of
msgid "type x"
msgstr ""

#: algolib.numerics.exp.exp:25 algolib.numerics.exp.exp:28 of
msgid "float"
msgstr ""

#: algolib.numerics.exp.exp of
msgid "returns"
msgstr ""

#: algolib.numerics.exp.exp:27 of
msgid "The exponential e**x."
msgstr ""

#: algolib.numerics.exp.exp of
msgid "rtype"
msgstr ""

#: ../source/api/algolib.numerics.rst:32
msgid "algolib.numerics.rounding module"
msgstr ""

#: algolib.numerics.rounding:1 of
msgid "Rounding functions for numerical values."
msgstr ""

#: algolib.numerics.rounding:3 of
msgid ""
"This module provides functions to perform rounding of floating-point numbers "
"using different strategies."
msgstr ""

#: algolib.numerics.rounding:7 of
msgid "Functions"
msgstr ""

#: algolib.numerics.rounding:8 of
msgid "round_half_away_from_zero(x)"
msgstr ""

#: algolib.numerics.rounding:9 of
msgid "Rounds a number to the nearest integer, rounding halves away from zero."
msgstr ""

#: algolib.numerics.rounding:11 of
msgid "round_even(x)"
msgstr ""

#: algolib.numerics.rounding:12 of
msgid ""
"Rounds a number to the nearest integer, rounding halves to the nearest even "
"integer."
msgstr ""

#: algolib.numerics.rounding.round_even:1 of
msgid ""
"Round a number to the nearest integer, rounding halves to the nearest even "
"integer."
msgstr ""

#: algolib.numerics.rounding.round_even:3 of
msgid ""
"This rounding method is also known as \"bankers' rounding\". When the "
"fractional part of the number is exactly 0.5 or -0.5, the number is rounded "
"to the nearest even integer."
msgstr ""

#: ../source/api/algolib.numerics.rst algolib.numerics.rounding.round_even
#: algolib.numerics.rounding.round_half_away_from_zero of
msgid "Parameters"
msgstr ""

#: algolib.numerics.rounding.round_even:7
#: algolib.numerics.rounding.round_half_away_from_zero:3 of
msgid "The number to round."
msgstr ""

#: ../source/api/algolib.numerics.rst algolib.numerics.rounding.round_even
#: algolib.numerics.rounding.round_half_away_from_zero of
msgid "Returns"
msgstr ""

#: algolib.numerics.rounding.round_even:10
#: algolib.numerics.rounding.round_half_away_from_zero:6 of
msgid "The rounded integer."
msgstr ""

#: ../source/api/algolib.numerics.rst algolib.numerics.rounding.round_even
#: algolib.numerics.rounding.round_half_away_from_zero of
msgid "Return type"
msgstr ""

#: algolib.numerics.rounding.round_even:14
#: algolib.numerics.rounding.round_half_away_from_zero:10 of
msgid "Examples"
msgstr ""

#: algolib.numerics.rounding.round_half_away_from_zero:1 of
msgid "Round a number to the nearest integer, rounding halves away from zero."
msgstr ""

#: ../source/api/algolib.numerics.rst:40
msgid "algolib.numerics.sqrt module"
msgstr ""

#: algolib.numerics.sqrt.newton_sqrt:1 of
msgid "Square root via Newton–Raphson iteration (overflow-safe update)."
msgstr ""

#: algolib.numerics.sqrt.newton_sqrt:4 algolib.numerics.trig.tan:4 of
msgid "Notes"
msgstr ""

#: algolib.numerics.sqrt.newton_sqrt:5 of
#, python-brace-format
msgid ""
"Uses the overflow-safe iteration y_{k+1} = 0.5 * (y_k + x / y_k). The "
"initial guess is derived from the binary exponent of `x` (parsed via "
"float.hex) to match the magnitude of sqrt(x)."
msgstr ""

#: ../source/api/algolib.numerics.rst:48
msgid "algolib.numerics.stable module"
msgstr ""

#: algolib.numerics.stable.hypot:1 of
#, python-brace-format
msgid "Stable :math:`\\sqrt{x^2 + y^2}` with overflow/underflow protections."
msgstr ""

#: algolib.numerics.stable.hypot_n:1 of
#, python-brace-format
msgid ""
"Stable Euclidean norm for :math:`N` components: :math:`\\sqrt{\\sum_i "
"xs[i]^2}`."
msgstr ""

#: ../source/api/algolib.numerics.rst:56
msgid "algolib.numerics.trig module"
msgstr ""

#: algolib.numerics.trig.cos:1 of
msgid "Cosine of an angle (system backend)."
msgstr ""

#: algolib.numerics.trig.cos:3 algolib.numerics.trig.sin:3
#: algolib.numerics.trig.tan:9 of
msgid "Input angle in radians."
msgstr ""

#: algolib.numerics.trig.cos:6 of
msgid "``cos(x)`` evaluated by the active numerics backend."
msgstr ""

#: algolib.numerics.trig.sin:1 of
msgid "Sine of an angle (system backend)."
msgstr ""

#: algolib.numerics.trig.sin:6 of
msgid "``sin(x)`` evaluated by the active numerics backend."
msgstr ""

#: algolib.numerics.trig.tan:1 of
msgid "Tangent of an angle (system backend)."
msgstr ""

#: algolib.numerics.trig.tan:5 of
msgid ""
"Argument-reduction and non-finite handling are performed inside the active "
"backend (see ``_backend.SystemTrigBackend.tan``). Keeping this wrapper free "
"of extra reduction ensures consistent periodicity tests."
msgstr ""

#: algolib.numerics.trig.tan:12 of
msgid "``tan(x)`` evaluated by the active numerics backend."
msgstr ""

#: ../source/api/algolib.numerics.rst:64
msgid "algolib.numerics.trig\\_pure module"
msgstr ""

#: algolib.numerics.trig_pure:1 of
msgid "Numerical trig functions: sin / cos / tan"
msgstr ""

#: algolib.numerics.trig_pure:3 of
msgid "No stdlib math usage in implementation"
msgstr ""

#: algolib.numerics.trig_pure:4 of
msgid "Cody-Waite style range reduction by π/2"
msgstr ""

#: algolib.numerics.trig_pure:5 of
msgid "Polynomial approximation on [-π/4, π/4]"
msgstr ""

#: algolib.numerics.trig_pure.PureTrigBackend:1 of
msgid "Bases: :py:class:`object`"
msgstr ""

#: algolib.numerics.trig_pure.PureTrigBackend:1 of
msgid "Wrap current pure-Python trig implementations as a backend."
msgstr ""

#: ../source/api/algolib.numerics.rst:72
msgid "Module contents"
msgstr ""
